package dei.fwebsocket;

import dei.jsonobjectprocessing.JsonObjectProcessing;
import dei.serverthread.Scheduler;
import dei.serverthread.ServerThread;
import dei.serverthread.UsersList;
import java.io.IOException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.servlet.http.HttpSession;
import javax.websocket.EndpointConfig;


import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.OnClose;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;
import org.json.simple.JSONObject;

/**
 * @name FServerEndpoint
 * @description this POJO receives several anotations from the javax.websocket
 * library. Its methods allow for the server to deal with the callbacks
 * generated by the Websocket implementation.
 *
 * @author MÃ¡rio Alves Pereira
 * @contact mgreis@student.dei.uc.pt
 * @Copyright
 */
@ServerEndpoint(value = "/FServerEndpoint", configurator = GetHttpSessionConfigurator.class)
public class FServerEndpoint {

    /**
     * fsessions contains the user identifier as a key and its correspondent
     * FServerSession object as a value The clientID is the counter that gives
     * each client an unique ID; processor has the necessary logic to encode and
     * decode the JSON messages sent and received;
     */
    static ConcurrentHashMap<Integer, FServerSession> fSessions = new ConcurrentHashMap<Integer, FServerSession>();
    private static int clientID = 0;
    static JsonObjectProcessing processor = new JsonObjectProcessing();

    /**
     * This next three attributes are not part of the solution. They are used to
     * generate messages to random connected users in order to allow the system
     * to be tested. sessionUSer allows us to relate a session to a certain user
     * identifier. It is necessary to identify which user has closed the
     * connection in order to remove it from the userList that serverThread uses
     * to generate and send messages to clients
     */
    static ConcurrentHashMap<Session, Integer> sessionUser = new ConcurrentHashMap< Session, Integer>();
    static UsersList usersList = new UsersList();
    static ServerThread serverThread = new ServerThread(usersList, fSessions);
    static boolean serverThreadNotStarted = true;
    
    
    
    private HttpSession httpSession;

    //static Scheduler scheduler = new Scheduler(fSessions, usersList);
    /**
     * @OnOpen allows us to intercept the creation of a new session. The session
     * class allows us to send data to the user. In the method onOpen, we'll let
     * the user know that the handshake was successful.
     */
    @OnOpen
    public void onOpen(Session session ) {
        System.out.println( "Cookie!!" +((PrincipalWithSession) session.getUserPrincipal()).getSession().getId());
        if (serverThreadNotStarted) {
            System.out.println("STARTING");
            serverThread.start();
            serverThreadNotStarted = false;
        }

    }

    /**
     * @OnMessage When a user sends a message to the server, this method will
     * intercept the message and allow us to react to it. For now the message is
     * read as a String.
     */
    @OnMessage
    public void onMessage(String message, Session session) {
        System.out.println("Message from " + session.getId() + ": " + message);

        //decode de message into a JSON object
        JSONObject messageObject = processor.decodeMessage(message);

        switch ((String) messageObject.get("Type")) {

            /**
             * If the message is an handshake it is necessary to verify if the
             * identifier is zero or different from zero.
             */
            case "Handshake": {
                /**
                 * If the identifier is zero it means we have a new client. We
                 * will have to create a new FServerSession object and give the
                 * client a new identifier. Then we need to send the identifier
                 * back to the client has an Handshake message and store the
                 * FServer session in the hashmap with the client identifier has
                 * the key
                 */
                if (messageObject.get("Identifier").equals("0")) {
                    try {
                        FServerSession thisSession = new FServerSession(session);
                        clientID += 1;
                        System.out.println("ClientID: " + clientID);
                        thisSession.setHandlerId(clientID);

                        thisSession.handshake();
                        fSessions.put(thisSession.getHandlerId(), thisSession);

                        /**
                         * this last two lines are not part of the
                         * implementation. They are used to populate the data
                         * structures that support the thread that feeds the
                         * server with messages
                         */
                        sessionUser.put(session, thisSession.getHandlerId());
                        usersList.addUser(new Integer(thisSession.getHandlerId()));

                    } catch (IOException ex) {
                        Logger.getLogger(FServerEndpoint.class.getName()).log(Level.SEVERE, null, ex);
                        System.out.println("Error");
                    }

                    /**
                     * if the identifier is different from zero it means this is
                     * a reconnection attempt. we must retrieve the clients
                     * FServerSession, close the old session object and
                     * substitute it for the new one. finally we call the
                     * reconnect method in order to send the handshake message
                     * back to the client and ressend all messages waiting in
                     * queue
                     */
                } else {
                    FServerSession thisSession = fSessions.remove(Integer.valueOf((String) messageObject.get("Identifier")));
                    try {
                        thisSession.getSession().close();
                    } catch (IOException ex) {
                        Logger.getLogger(FServerEndpoint.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    thisSession.setSession(session);

                    /**
                     * this next line is not part of the implementation. it is
                     * used to populate the data structures that support the
                     * thread that feeds the server with messages
                     */
                    sessionUser.put(session, thisSession.getHandlerId());
                    try {
                        thisSession.reconnect();
                    } catch (IOException ex) {
                        Logger.getLogger(FServerEndpoint.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    fSessions.put(Integer.valueOf((String) messageObject.get("Identifier")), thisSession);
                }
                break;
            }
            /**
             * If the message type is message we should retrieve the client's
             * fServerSession object and call its onMessage() method in order to
             * process the incoming message
             */
            case "Message": {

                FServerSession thisSession = fSessions.remove(Integer.valueOf((String) messageObject.get("Identifier")));
                thisSession.onMessage(messageObject);
                fSessions.put(Integer.valueOf((String) messageObject.get("Identifier")), thisSession);
                break;
            }
            /**
             * If the message type is ACK we should retrieve the client's
             * fServerSession object and call its onACK() method in order to
             * process the incoming message
             */
            case "ACK": {

                FServerSession thisSession = fSessions.remove(Integer.valueOf((String) messageObject.get("Identifier")));
                thisSession.onAck(messageObject);
                fSessions.put(Integer.valueOf((String) messageObject.get("Identifier")), thisSession);
                break;
            }
        }

    }

    /**
     * The user closes the connection.
     *
     * Note: you can't send messages to the client from this method
     */
    @OnClose
    public void onClose(Session session) {
        /**
         * this lines are not part of the implementation. They are used to
         * update the data structures that support the thread that feeds the
         * server with messages
         */
        Integer user = sessionUser.get(session);
        System.out.println("User " + user + " has disconnected.");
        usersList.removeUser(user);
        sessionUser.remove(session);

    }

    /*@onError
    public void onError(Throwable ex,Session session){
        System.out.println(ex);
    }*/
    
    
    public void setHttpSession(HttpSession httpSession)
    {
    if (this.httpSession != null)
        throw new IllegalStateException("HttpSession has already been set!");

    this.httpSession = httpSession;
    }

}
