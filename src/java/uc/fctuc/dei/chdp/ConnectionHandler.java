package uc.fctuc.dei.chdp;

import java.io.IOException;

/**
 * @name ConnectionHandler
 * @description The Connection Handler provides an interface to implement all
 *              actions required to establish a connection and reestablish a
 *              failed one.
 * 
 * @author Naghmeh Ivaki and Filipe Araujo
 * @contact naghmeh@dei.uc.pt
 * @Copyright
 */

public abstract class ConnectionHandler {

	public enum ConnectionType {
		NEW, RECOVERY
	}

	protected int MAX_RECONN_TIME = 5; // minutes

	/**
	 * Each Connection Handler has a unique identifier that is generated by the
	 * server to distinguish a brand new connection from a connection that is
	 * establish for the recovery purposes. It is exchanged by means of a
	 * handshake process, implemented in method handshake(), once a connection
	 * is successfully created.
	 */
	protected int handlerId = 0;
	protected ConnectionType type = null;

	public int getHandlerId() {
		return this.handlerId;
	}
        public void setHandlerId(int handlerId) {
		this.handlerId=handlerId;
	}

	/**
	 * The Connection Handler allows the application to define the maximum time
	 * (MAX_RECONN_TIME) permitted for recovery process through the method
	 * setMaxReconnTime().
	 */

	public void setMaxReconnTime(int t) {
		this.MAX_RECONN_TIME = t;
	}

	public int getMaxReconnTime() {
		return MAX_RECONN_TIME;
	}

	public ConnectionType getType() {
		return type;
	}

	/**
	 * The handshake process used to exchange the identifier works as follows.
	 * Upon establishment of a new connection, the client sends 0 as its
	 * identifier, which allows the server to identify that the connection is
	 * new. Then the connection type is set to NEW and a unique identifier is
	 * generated and sent back to the client. When the client establishes a
	 * connection for recovery purposes, the value of handlerId is sent to the
	 * server, so that the server can identify that the connection is created to
	 * replace a failed one. In this case the connection type is set to
	 * RECOVERY.
	 */
	protected abstract void handshake() throws IOException;

	/**
	 * The actions to reconnect and resend the lost data must be implemented in
	 * method reconnect().
	 */
	protected abstract void reconnect() throws IOException;

	public void close() {
		HandlersSynchronizer.deregister_handler(this.handlerId);
	}
}
